{"pages":[{"title":"","text":"你好，我是Vincent欢迎光临我的博客我是一名程序猿本博客会记录我的学习历程和生活随笔希望天天开心٩(◍’u’◍)و✧","link":"/about/index.html"}],"posts":[{"title":"Ⅲ.使用Spring Initializer快速创建Spring Boot项目","text":"  相对对前面的spring boot创建hello world的应用的方法，spring boot还支持使用Spring Initializer快速创建Spring Boot项目，会比前者更快捷方便很多。  下面使用IDEA来使用Spring Initializer这个功能，当然官方推荐的STS也支持这个功能。 1.使用Spring Initializer创建新的工程  在创建之前需要联网，保证可以自动下载所需要的包。  同样的new一个project，不过选择Spring Initializer。   假如版本不同的时候，类似我看其他的教程是使用1.5.9的版本，这里可以提供的选择里面已经没有1.5.9的版本了，但是没有关系，找好依赖就可以了，类似我这里需要一个web的功能，但是左边的Dependencies中并没有这个选项，可以直接搜依赖，然后点击后，右边就会出现你已经选择的依赖。完成后，下一个页面也继续不用改变，直接选择Finish，完成系统的搭建。   类似前面的上一篇文章我是看视频教程里使用1.5.9版本的spring boot，我这里是使用了2.2.6版本，由于之前下载的本地仓库里没有2.2.6的依赖，就会报错，而且没不主动给你下载，是因为网络问题，所以可以参考前一篇文章使用阿里的镜像，然后系统会自动帮你下载好所需要的依赖。 软件右下角有软件下载的进度。下载好之后，会在工程下面的External Libraries下会出现除了jdk1.8（博主使用的版本）以外的maven的依赖包。这个时候检查maven project的视图，会发现Plugins和Dependencies都是没有红色波浪线的，是个良好的工程。   经过第一次使用springboot的1.59版本和2.2.6版本，你可以在本地的仓库看到两个不同的版本都被下载下来了。 2.编写业务逻辑  通过点击main下的java文件夹可以发现，工程所需要的主程序已经自动有了，所以接下来只需专注在业务逻辑即可，同样同样按上一章的教程添加controller文件。 123456789101112131415161718192021package com.myblog.springboot.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;//这个类的所有方法返回的数据直接写给浏览器，（如果是对象转为json数据）/*@ResponseBody // 因为很多方法都可能要用到，所以放到前面，说明这这个类的所有方法返回的数据直接写给浏览器，（如果是对象转为json数据）@Controller*/@RestController //在spring4.2版本以后，已经包含了 ResponseBody 和Controllerspublic class HelloController { @RequestMapping(\"/hello\") //收到hello请求 public String hello(){ return \"hello world quick!\"; } // RESTAPI的方式}   按照上一章的方法启动程序，可以看到是正常可以使用的。 3.resources的目录结构说明  ● static：保存所有的静态资源；类似 js css images。  ● templates：保存所有的模板页面（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）。  ● application.properties：Spring Boot应用的配置文件；可以修改spring boot自动配置的默认值；类似修改其端口，可以使用server.port=8082,修改后，端口要使用8082才能使用了。   ps：application.properties和application.yaml都可以是配置文件，可以在resources下新建application.yaml进行配置。","link":"/2020/04/11/LN-springboot3/"},{"title":"IV.导入他人项目的注意事项","text":"  有时候我们在网上看到优秀的关于springboot的开源代码，就想着下载下来跑一下尝试一下效果，但是发现项目各处都出现了报错的地方，本节想要尽可能提供一些解决方法。 1.项目配置  点击file进入setting-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven，设置成属于自己原来的值。   使用快捷键ctrl+shift+Alt+s进入下列页面，设置为自己原来的值（+号添加文件），如果这里不知道怎么设置，可以打开原来自己的项目看相关值。 2.Exrernal Libraries出现库没下载下来  这种情况是很大程度是因为网络问题，添加一个阿里的镜像就可以自动下载了。 1234567891011121314&lt;repositories&gt;&lt;repository&gt; &lt;id&gt;maven-ali&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt; &lt;/snapshots&gt;&lt;/repository&gt;&lt;/repositories&gt; 3.假如出现cannot resolve symbol的问题  在前面的工作已经做完的情况下，还出现此类问题时，将鼠标移至问题上，依照提示进行操作。","link":"/2020/04/14/LN-springboot4/"},{"title":"IV.加载指定的配置文件","text":"  上一章介绍了使用@ConfigurationProperties和@value，他们从全局配置文件中获取值并映射到实体类中所对应的属性里。但是全部默认值都放在全局配置变量中将非常臃肿功能，所以本章将介绍三种不同的方法来加载外部指定的配置文件来放在环境中。  再次强调，上一章讲的是从全局配置文件中获取值并映射到实体类中所对应的属性，这一章讲的是加载指定的配置文件来放在环境，两者不是冲突的关系，即你可以不加载外部指定的配置文件来放在文件中，直接使用@ConfigurationProperties或者@value映射，也可以加载外部指定的配置文件再来使用映射功能。 1.PropertySource来加载指定的配置文件  在上一章的文件基础上，删除Person所对应的全局配置值后，在resources文件下右键新建【new file】person.properties文件，如下所示。 123456789person.last-name=路飞person.age=18person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=${person.hello:hello}_dogperson.dog.age=15   将原来的Person.java文件添加为使用PropertySource的方式来加载外部的配置文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.myblog.springboot.bean;import org.springframework.stereotype.Component;import org.springframework.context.annotation.PropertySource;import java.util.Date;import java.util.List;import java.util.Map;@PropertySource(value = {\"classpath:person.properties\"})// 告诉springboot加载内路径下的person.properties的内容，并把他们绑定都到Person对象中//加载指定的属性文件的配置到环境中@Component@ConfigurationProperties(prefix = \"person\")//主配置中的属性映射到实体类中所对应的属性public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @Override public String toString() { return \"Person{\" + \"lastName='\" + lastName + '\\'' + \", age=\" + age + \", boss=\" + boss + \", birth=\" + birth + \", maps=\" + maps + \", lists=\" + lists + \", dog=\" + dog + '}'; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Boolean getBoss() { return boss; } public void setBoss(Boolean boss) { this.boss = boss; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } public Map&lt;String, Object&gt; getMaps() { return maps; } public void setMaps(Map&lt;String, Object&gt; maps) { this.maps = maps; } public List&lt;Object&gt; getLists() { return lists; } public void setLists(List&lt;Object&gt; lists) { this.lists = lists; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; }}   最后的效果如下。 2.ImportResource来加载spring的配置文件  Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别。如果需要导入spring的配置文件，则需要ImportResource来加载spring的配置文件。想让Spring的配置文件生效且加载进来，需要@ImportResource标注在一个配置类【这里我的主配置类是】上。  右键com.myblog.springboot02新建java class，取名为service.HelloService文件  右键resources如图输入beans来新建beans.xml文件注意不能输入beans.xml,不然就变成beans.xmll.xml。 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.myblog.springboot02.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt;   在测试类中添加下列代码。 12345678@AutowiredApplicationContext ioc; //注入ioc容器@Testpublic void testHelloService(){ // 测试容器中有无helloService boolean b = ioc.containsBean(\"helloService\"); System.out.println(b);}   运行testHelloService，但是显示结果告诉我们不能直接导入spring的配置文件，所以需要使用我们上面说的ImportResource。   想让Spring的配置文件生效且加载进来，需要@ImportResource标注在一个配置类【这里我的主配置类是】上。   可以看到spring的配置文件beans.xml被成功导入。   由于考虑到导入spring配置文件时需要新建再导入，很麻烦，所以springboot提供了一种快捷的导入方式：推荐使用全注解的方式。具体的实现方式是：   @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件【可以新建一个配置类或者使用主配置类】。   @Bean：将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名。   记得在测试这段的时候，需要把上次使用的@ImportResource(locations = {\"classpath:beans.xml\"})注释掉,在com.myblog.springboot文件夹下新建配置类，类名为config.MyAppConfig。 123456789101112131415package com.myblog.springboot02.config;import com.myblog.springboot02.service.HelloService;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration //指明当前类是一个配置类；就是来替代之前的Spring配置文件public class MyAppConfig { @Bean //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 public HelloService helloService(){ //容器中这个组件默认的id为helloService System.out.println(\"配置类@Bean给容器中添加组件了，运行成功！\"); return new HelloService(); }}   从运行结果可以知道这种方法是可行且方便的。 3.总结  ● @PropertySource来加载指定的配置文件  ● @ImportResource来加载spring的配置文件  ● @Configuration和@Bean组合来加载spring的配置文件【官方推荐】","link":"/2020/04/14/LN-springboot6/"},{"title":"Ⅷ.Spring Boot与日志","text":"  日志的使用包括日志门面（抽象层）和日志实现。我们在使用的时候只需要调用日志门面即可。我们这里选用日志门面（抽象层）：slf4j和日志实现：logback来进行讲解。在日志使用的时候不用考虑日志实现，只需要考虑日志的实现就可以了。 1.日志门面slf4j与日志实现logback的使用在官网上，我们可以看到slf4j的使用，slf4j用户手册。 12345678910import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); //geilongger是获取记录器的东西，获取类的信息 logger.info(\"Hello World\"); }}   slf4j和logback使用方法：  在使用slf4j和logback时，需要在系统中导入slf4j的jar包和logback的实现jar。 2.日志门面slf4j与其他日志实现方法的使用  如果想使用日志门面slf4j与其他日志实现的时候，可以参考官方给出的这张图片。   从图中可以看到，第二行绿色方框所代表是为日志门面slf4j，只要是使用使用slf4j，日志门面就一定不会改变。在第三行里，蓝色为日志实现，由于一些日志实现出现的时候比较早，没有考虑到slf4j的出生，所有要使用灰色的日志实现需要淡绿色的适应层来适应。在第四行里，是早于slf4j出现的日志实现。   在第一列中，由于只使用日志门面而没有采用日志方法，则日志记录后输出到一个空的位置。正确的用法应该是第二列，日志使用日志门面后选择不同的日志实现进行输出。第三和第四咧都是使用早于slf4j出现的日志实现，所以需要有适应层的存在。第五列是使用slf4j提供的简单的日志实现。第六列是导入slf4j提供的没有什么操作的日志实现。   每一个日志实现都有不同的配置文件，slf4j根据不同日志实现进行不同的配置。 3.转换其他日志门面统一为slf4j的方法  由于不同的框架在使用日志文件时采用不同的日志门面，类似spring使用commons-logging的日志门面，hibernate使用jboss-logging，mybatis使用不一样的日志门面，所有需要统一为一个指定的日志门面。  这里我们将不同的日志门面转化统一为slf4j。   首先先注意左上角的子图，在左边的一个竖列是正常使用的slf4j和logback的方式。在右侧的那些方框是指使用了别的日志门面的方式。如果直接想替换成slf4j的方式的话，需要把依赖删除后，加入方框左下角提醒的jar，尚硅谷的雷丰阳老师称为偷天换日包，狸猫换太子包，也就是两个不同的包，前者有什么类，后者也有相同的类名，这样子就不会出错了。后者也有相同的类指向slf4j，再由slf4j指向日志实现。   右上角的子图和左下角的子图都是在使用优先slf4j出现之前的日志实现时需要要做的事情，其实跟上者没什么区别，只是在日志门面与日志实现之间增加了一个适应层而已。 4.日志实战使用  springboot的日志在项目创建的时候就已经自动配置好了。下列展示日常中常用的日志的使用方式。 1234567891011121314151617181920212223242526272829303132package com.myblog.springboot;import org.junit.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot03LoggingApplicationTests { Logger logger = LoggerFactory.getLogger(getClass());//创建日志记录的记录器 @Test public void contextLoads() { //System.out.println(); //日志的级别；trace&lt;debug&lt;info&lt;warn&lt;error logger.trace(\"我是trace日志...\");//跟踪信息时使用 logger.debug(\"我是debug日志...\");//调试时使用 logger.info(\"我是info日志...\");//自己定义的信息 logger.warn(\"我是warn日志...\");//警告信息 logger.error(\"我是error日志...\");//错误信息 //SpringBoot默认使用的是info级别的【也称为root级别】，也就是在输出日志的时候，不会输出trace和debug级别的信息。 //如果想设定级别，则可以在配置文件中使用logging.level来进行设置，类似设置我当前的包的级别为trace，则是如下所示 //logging.level.com.myblog=trace //技巧：通过设置输入日志的级别，系统就只显示这个级别以上的日志信息，就不会一条条去注释日志语句了。 }} 5.日志的配置  上一节我们已经使用了日志的配置之一，也就是设置日志的输出等级，接下来说明logging.file和logging.path的区别，同样的，这两个的配置也是在配置文件中进行配置。 logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件夹 (none) my.log 输出日志到my.log文件 (none) 指定目录 my.log 输出到指定目录的spring.log【名字是官方定义的】文件中   如果logging.file和logging.path都没有指定的情况下，指定输出日志在工作台中。   如果是使用logging.file不使用logging.path的话，会在工程路径下生成指定名字的log文件【例如logging.file=springboot.log】,也可以通过指定路径的方式进行生成【例如logging.file=E:/springboot.log】   logging.file和logging.path是互相矛盾的，一般不混合使用，即使同时出现，也只会设置logging.file中的内容。logging.path里指定目录，而不考虑文件名，因为文件名是官方已经给出的名字【例如/spring/log,是指在工程所在的目录下新建spring文件夹，里再新建log文件夹，把日志文件写在spring.log并保存，注意/是绝对路径./是相对路径，在idea的工程里是看不到的，因为是工程同个目录下】","link":"/2020/04/15/LN-springboot8/"},{"title":"V.配置文件值注入与自动单元测试","text":"  配置文件有分yaml格式和properties和两种格式，可以作为配置文件值注入。映射值的方式有ConfigurationProperties和value两种。同时本章介绍要介绍idea在springboot上的自动单元测试。 1.yaml格式注入文件值  新建两个java文件(分别为Person和Dog)，并将yaml的值映射到到java文件属性中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//Person.javapackage com.myblog.springboot.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@Component@ConfigurationProperties(prefix = \"person\")public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @Override public String toString() { return \"Person{\" + \"lastName='\" + lastName + '\\'' + \", age=\" + age + \", boss=\" + boss + \", birth=\" + birth + \", maps=\" + maps + \", lists=\" + lists + \", dog=\" + dog + '}'; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Boolean getBoss() { return boss; } public void setBoss(Boolean boss) { this.boss = boss; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } public Map&lt;String, Object&gt; getMaps() { return maps; } public void setMaps(Map&lt;String, Object&gt; maps) { this.maps = maps; } public List&lt;Object&gt; getLists() { return lists; } public void setLists(List&lt;Object&gt; lists) { this.lists = lists; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; }} 12345678910111213141516171819202122232425//Dog.javapackage com.myblog.springboot.bean;public class Dog { private String name; private Integer age; @Override public String toString() { return \"Dog{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; }}   右键resources并新建File，输入文件名为application.yml【这里也可以使用yaml作为结尾】。 1234567891011121314person: lastName: zhangsan age: 18 boss: false birth: 2017/12/12 maps: k1: v1 k2: v2 lists: - lisi - zhaoliu Dog: name: 小狗 age: 2   如果在写yaml文件时需要提醒注释，则需要添加下列的依赖。 12345&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;   这里提供我的poml文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-02-config&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-02-config&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;maven-ali&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 2.自动单元测试  在src文件夹下的test有提供一个自动单元测试的文件，在我这里是SpingBoot02ConfigApplicationTests.java。 12345678910111213141516171819202122package com.myblog.springboot;import com.myblog.springboot.bean.Person;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class) //用SpringRunner驱动器来跑@SpringBootTest //SpringBoot单元测试;public class SpringBoot02ConfigApplicationTests { @Autowired Person person; @Test public void contextLoads() { System.out.println(person); }}   然后使用@Test旁边的运行符就可以运行自动单元测试，此时会将yaml里的值赋值给自动单元测试模块，效果如下。 3.properties格式注入文件值  使用上面的文件并将创建的yaml文件删除后，使用properties文件。 123456789person.last-name=张三${random.uuid}person.age=${random.int}person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=${person.hello:hello}_dogperson.dog.age=15   按照前面说明的自动单元测试的方法运行后，可以同样看到文件值的注入，如下所示。   但是我们可以注意到中文出现乱码的情况，需要将properties设置由原本的GBK设置为UTF-8，同时勾选转换为ascill。【在setting中输入file enc可以找到】，记得设置完，要回去把properties文件的乱码修改正常。再运行程序就可以正常运行了。【GBK设置是每次项目生成时都会设置的，如果要使用中文，则需要在项目生成后就进行设置，以免出错】。 4.不同的文件获取值的方式  上述所用的文件获取值的方式都是基于ConfigurationProperties方式，这里还有一种value的方式可以获取。  value可以获取字面值；从环境变量、配置文件中获取值；还可以获取spring运算值。  将第1小节中的Person.java文件修改为如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.myblog.springboot.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import org.springframework.beans.factory.annotation.Value;import java.util.Date;import java.util.List;import java.util.Map;@Componentpublic class Person { /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/${key}从环境变量、配置文件中获取值/#{SpEL}spring的表达式语言\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ @Value(\"${person.last-name}\") //从环境变量、配置文件中获取值 private String lastName; @Value(\"#{11*2}\") //表达式文件 private Integer age; @Value(\"true\") //字面量 private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @Override public String toString() { return \"Person{\" + \"lastName='\" + lastName + '\\'' + \", age=\" + age + \", boss=\" + boss + \", birth=\" + birth + \", maps=\" + maps + \", lists=\" + lists + \", dog=\" + dog + '}'; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Boolean getBoss() { return boss; } public void setBoss(Boolean boss) { this.boss = boss; } public Date getBirth() { return birth; } public void setBirth(Date birth) { this.birth = birth; } public Map&lt;String, Object&gt; getMaps() { return maps; } public void setMaps(Map&lt;String, Object&gt; maps) { this.maps = maps; } public List&lt;Object&gt; getLists() { return lists; } public void setLists(List&lt;Object&gt; lists) { this.lists = lists; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; }}   此时运行自动测试单元，可以得到如设置值一样的效果。   我们可以注意到ConfigurationProperties和value两种方式的不同之处。 ConfigurationProperties value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持   如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value。  如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties。  这里需要清楚的是ConfigurationProperties和value都是在主配置中的属性映射到实体类中所对应的属性里，下一章才会讲怎么从其他地方加载指定的属性文件的配置到环境中。","link":"/2020/04/14/LN-springboot5/"},{"title":"Ⅱ.Spring Boot Hello World!","text":"1. 实现功能   当浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串。 2. 创建maven工程并导入Spring Boot相关依赖  如图所示，项目名要跟模块名一样，不然可能会报错。   当工程里出现如下图所示时，选Enable Auto-Import，在写入相关依赖后会自动下载依赖包。 3.导入spring boot相关的依赖  在springboot官网找到依赖并添加到工程里，复制粘贴后要检查会不会因为语法问题报错。 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;   大概的效果是这样子：   加入依赖后要看一下应用下面的External Libraries下除看jdk的依赖包以为还有没有其他包，如Maven开头的包，如果没有的话，需要添加阿里的镜像来进行下载，当你添加完后，会发现系统自动进行下载，这个时候需要等待一段时间。 1234567891011121314&lt;repositories&gt;&lt;repository&gt; &lt;id&gt;maven-ali&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt; &lt;/snapshots&gt;&lt;/repository&gt;&lt;/repositories&gt; 4.编写主程序  在main下的java下添加新类，我这里添加为com.myblog.HelloWorldMainAppliction。 123456789101112131415package com.myblog; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @SpringBootApplication 标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication { public static void main(String[] args) { // 启动Spring应用 SpringApplication.run(HelloWorldMainApplication.class,args); }} 5.编写Controller与Service  在com.myblog下添加新类，我这里添加为com.myblog.HelloWorldMainAppliction。 1234567891011121314package com.myblog.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController { @ResponseBody @RequestMapping(\"/hello\") //接受来自浏览器的hello请求 public String hello(){ return \"Hello World!\"; //返回 Hello World! }} 6.测试  由于spring boot的便捷性，不像ssm中需要整合服务器比较复杂的运行，spring boot在主程序中直接运行main方法就可以了[主函数隔壁的三角符号]。  运行后从终端中显示的 TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http) 可以知道，端口是8080。  在浏览器中输入localhost：8080后会出现错误，那是因为没有给输入 所以没有返回，在输入localhost：8080/hello时，便成功运行! 7.部署  由于spring boot的特性，使用在pom.xml文件中插入下列语句可以使用插件将应用打包为一个可执行的jar包，从而无需在目标服务器安装tomcat环境等繁琐的东西。 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;   假如IDEA的右边没有附着maven project的视图时，可以在setting-&gt;Appearance&amp;Behavio-&gt;Appearance中，勾中Show tool window bars,如图所示：   或者可以直接点击左下角，类似小电脑的图标，也是可以直接呼出右边栏。   选择maven project，准备生成jar包，假如在打开时看到应用报错，指向Plugins文件夹时（Plugins文件夹下有红色波浪线），因为第一次生成的时候Plugins、Dependengcies这些包还没下载，打开应用下的Lifecycle目录，并双击package，会生成jar包，不过第一次生成前会帮你下载好Plugins这些包,如果还是报红，打开本地仓库的文件夹（在上一节IDEA的设置中有提到），类似如果是org.apache.maven.plugins:maven-clean-plugin:2.6.1报错，则找到文件夹\\repository\\org\\apache\\maven\\plugins\\maven-clean-plugin\\2.6.1下删除以LastUPdated为结尾的文件，依次类推删除类似其他报错的文件，然后右击应用选择maven重新reimport，如下图所示。这个过程有点久，取决于你的网速。如果重复删除还是会出现lastUpdated的文件，就退出软件，再载入一次。如果实在不行的话，运行maven中生命周期中的clean，这个时候会帮你重新下载一次，不过正常也是下载不了的，你可以按着提醒的错误来找到下载的网址，本地下载jar包后放进去   生成的jar在target文件夹下。   可以在终端使用使用java -jar的指令进行调试，效果如下，同样使用测试环节的方法可以看到Hello World！","link":"/2020/04/10/LN_springboot2/"},{"title":"Ⅶ.配置文件的使用方式","text":"1.针对不同的应用场景使用不同的配置文件  一个实际的工程可能在开发，测试，生产时的环境有所不同，这时可以使用profile来设置不同的配置文件。profile支持properties和yaml两种格式，不过yaml还特殊支持代码块的方式进行调用。   在properties格式下或者yaml格式  格式：application-(profies).properties/yml  eg：application-dev.properties/yml【在开发环境下】  eg：application-prod.properties/yml【生产环境下】  ps：可以自己制定profile的标签   如果在正常情况下，默认使用主配置文件application.properties文件，假如想使用application-dev.properties,就需要在主配置文件下使用spring.profiles.active的方式，这里是spring.profiles.active=dev,就可以使用配置文件application-dev.properties。  如图所示，我在resources文件夹下新建了application-dev.properties和application-prod.properties两个配置文件，并在主配置文件里使用了spring.profiles.active=dev来激活application-dev.properties   除此之外，yaml由于自己的语法的特性，还支持多文档块的方式。yaml可以使用---来切分不同的文档块。然后使用spring:profiles的方式来命名profile的标签，类似spring:profiles:dev，如果要激活哪个文档块，可以使用spring:profiles:activate的方式激活制定的profile。   类似spring:profiles:activate:dev。   如图所示，我制定了dev和prod的两个不同的profile，然后激活了prod这个profile。   激活方式除了在配置文件中使用的方法之外，还可以使用命令行的方式来激活，类似--spring.profiles.active=dev,命令行的方式会比配置文件中制定的优先级更高，也就是说，即使你在文件夹中制定了一种标签的配置文件，我在命令行运行的时候添加了激活方式，可以命令行的优先级大于前者，这方便了我们的调试运行工作。   在开发过程中可以如图在Run/Debug Configuration的Program arguments下设置命令行，如--spring.profiles.active=dev，如图所示。   最后一种激活方式是使用虚拟机的方式同样在Run/Debug Configuration的VM options下设置 ，如-Dspring.profiles.active=dev。   总结：不同的激活方式都是在检测到不同的profile标签的基础上去激活的，所有标签的制定不能有错。 2.配置文件的加载位置  spring boot启动的时候会在默认的位置扫描扫描application.properties或者application.yml进行配置。  默认位置扫描的优先顺序为：    file:./config/    file:./    classpath:/config/    classpath:/  如图所示，我在项目中新建了四个不同路径下的配置文件。   spring boot会按照优先顺序加载全部的配置的文件，相同的配置会按优先级覆盖，不同的配置会保存，这也就是互补设置。 3.添加外部的配置文件  同样的，我们也可以使用spring.config.location来添加外部的配置文件来作为默认的文件位置，不过这种方式是在项目打包之后，在运维时可能运用到的，用这种方式来加载项目以外的制定目录下的配置文件，同样的，这个时候加载进来的文件也会跟之前的文件形成互补设置。  此时指定的外部的配置文件优先级会更高一点。  类似在运行jar包时使用java -jar ***.jar –spring.config.loction=C:/application.properties。 4.外部配置的加载顺序  外部配置的加载在官网多达17种，这里只挑出常见的几种进行描述。  springboot会从下列的位置进行加载配置，优先级从高到低，所有的配置形成互补配置。   1.命令行参数   2.来自java:comp/env的JNDI属性   3.Java系统属性（System.getProperties()）   4.操作系统环境变量   5.RandomValuePropertySource配置的random.*属性值   6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件   7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件   8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件   9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件   10.@Configuration注解类上的@PropertySource   11.通过SpringApplication.setDefaultProperties指定的默认属性   使用说明：  1.在使用命令行参数时，为了节省书写配置文件的时间，可以直接命令行赋值。类似在运行jar包时使用java -jar ***.jar –server.port=8081 这样子可以直接设置端口号。使用格式：多个配置用空格分开； –配置项=值。  2.外部的配置文件放在当前路径下一起就可以被调用了。  3.第6到第9点可以总结为优先加载带profile标签的配置文件，再加载不带profile标签的文件，在这里面，由jar包外的配置文件到jar包内的配置文件进行扫描，此处是指打包好的jar包所在目录下，放置在身旁的配置文件，如果有这个文件的话，jar运行后，可以先调用外部的配置文件互补覆盖jar包内的配置文件，有利于运维，如图所示为jar包外的配置文件。","link":"/2020/04/14/LN-springboot7/"},{"title":"Ⅰ.spring Boot简介与环境搭建","text":"1. Spring Boot简介   ● 简化Spring应用开发的一个框架；  ● 整个Spring技术栈的一个大整合；  ● J2EE开发的一站式解决方案; 2. 使用的环境  ● java version “1.8.0_221”  ● Apache Maven 3.3.9  ● IntelliJ IDEA 2017.2.2 x64  ● SpringBoot 1.5.9. RELEASE 3. Maven设置 给maven 的settings.xml配置文件的profiles标签添加设置语句，将其指向jak-1.8。 12345678910111213 &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 4. IDEA设置将Maven配置进去IDEA中  1.在初始页的Configure中选取Settings选项  2.设置如图所示","link":"/2020/04/10/LN_springboot1/"},{"title":"冒泡排序","text":"1.基本思想  冒泡排序是一种交换排序，核心是冒泡，把数组中最小的那个往上冒，冒的过程就是和他相邻的元素交换。  重复走访要排序的数列，通过两两比较相邻记录的排序码。排序过程中每次从后往前冒一个最小值，且每次能确定一个数在序列中的最终位置。若发生逆序，则交换；有俩种方式进行冒泡，一种是先把小的冒泡到前边去，另一种是把大的元素冒泡到后边。 2.图解 3.实现逻辑● 比较相邻的元素。如果第一个比第二个大，就交换他们两个。● 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。,每次遍历都会当前遍历最大的数放在最后，最后的元素应该会是最大的数。● 所以上次遍历后产生的最大的数已经在后面了，所以不用再对其进行遍历了，所以每次两两交换的数量会变小（即减i）● 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 通过两层循环控制： ● 第一个循环（外循环），负责把需要冒泡的那个数字排除在外； ● 第二个循环（内循环），负责两两比较交换。 4.举个栗子假如有数组为[10,1,35,61,89,36,55] 第一趟排序： 第一次排序：10和1比较，10大于1，交换位置     [1,10,35,61,89,36,55] 第二次排序：10和35比较，10小于35，不交换位置  [1,10,35,61,89,36,55] 第三次排序：35和61比较，35小于61，不交换位置  [1,10,35,61,89,36,55] 第四次排序：61和89比较，61小于89，不交换位置  [1,10,35,61,89,36,55] 第五次排序：89和36比较，89大于36，交换位置   [1,10,35,61,36,89,55] 第六次排序：89和55比较，89大于55，交换位置   [1,10,35,61,36,55,89] 第一趟总共进行了六次比较，排序结果：       [1,10,35,61,36,55,89] 第二趟排序： 第一次排序：1和10比较，1小于10，不交换位置    [1,10,35,61,36,55,89] 第二次排序：10和35比较，10小于35，不交换位置  [1,10,35,61,36,55,89] 第三次排序：35和61比较，35小于61，不交换位置  [1,10,35,61,36,55,89] 第四次排序：61和36比较，61大于36，交换位置   [1,10,35,36,61,55,89] 第五次排序：61和55比较，61大于55，交换位置   [1,10,35,36,55,61,89] 第二趟总共进行了五次比较，排序结果：       [1,10,35,36,55,61,89] 按这样子的思路以此类推下去 假如数组有n个元素 第一个for循环 从上面的分析可以看到，第一趟遍历走了n次，把n个元素里最大的元素移到本次遍历的最后端 第二次遍历走了n-1次，把n-1个元素里最大的元素移到本次遍历的最后一端， 因为倒数第二次遍历，就可以把2元素里最大的移到本次遍历的最后一端，那么，就不用再遍历最后一个元素了，所以代码中第一个for循环只需要n-1； 第二个for循环 从上面的分析可以看到，第一趟遍历走了n次，把n个元素里最大的元素移到本次遍历的最后端 第二次遍历走了n-1次，把n-1个元素里最大的元素移到本次遍历的最后一端， 同样的，是不是每次遍历，都会少遍历一个元素呢，所以第二个for循环只需要n-i-1 5.代码实现及详解c++版本 12345678void bubble_sort(int arr[], int len) { int i, j; for (i = 0; i &lt; len-1; i++) //总遍历的次数 for (j = 0; j &lt; len - 1 -i; j++) //每次遍历需要走的个数 if (arr[j] &gt; arr[j+1]) swap(arr[j], arr[j+1]); } 6.分析如果有n个数，最多需要走n-1次遍历就可以排好平均时间复杂度：O(n^2)最佳时间复杂度：O(n)最差时间复杂度：O(n^2)空间复杂度：O(1) 7.参考https://zhuanlan.zhihu.com/p/122284534https://www.cnblogs.com/bigdata-stone/p/10464243.html","link":"/2020/08/02/Sort%EF%BC%9ABubble-Sort/"},{"title":"归并排序","text":"1.基本思想  归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。 2.图解 3.实现逻辑迭代法● 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列● 设定两个指针，最初位置分别为两个已经排序序列的起始位置● 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置● 重复步骤三直到某一指针到达序列尾● 将另一序列剩下的所有元素直接复制到合并序列尾 递归法 ● 将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素 ● 设定两个指针，最初位置分别为两个已经排序序列的起始位置 ● 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 ● 重复步骤三直到某一指针到达序列尾 ● 将另一序列剩下的所有元素直接复制到合并序列尾 5.代码实现及详解c++版本迭代版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354template&lt;typename T&gt; void merge_sort(T arr[], int len) { //使用指针来交换的方式 /* * 这道题超级考验数组传参时指针的知识 * */ T *a = arr; T *b = new T[len]; for (int seg = 1; seg &lt; len; seg += seg) { //第一个循环，让最初始的一个容器开始进行融合，然后容器内容从1到2到4 for (int start = 0; start &lt; len; start += seg + seg) { //第二个循环，让每次相邻的两个容器进行排序 int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len); // 比较的容器：第一个容器是从low到mid，第二个容器是从mid到high，然后循环的时候会一直增加两个容器的内容，也就是seg //low ，mid，high都是每次比较容器的下标，所以要跟长度相比取最小， // 有可能最后一次容器比较的时候，只有一个容器了，且容器的大小不足所以mid最后取到len，也可能第二容器不够seg了，只能取到len了 int k = low; //将本次比较的两个容器的起始头拿出来，在这里一个个赋值 int start1 = low, end1 = mid; //将两个容器的起始头拿出来 int start2 = mid, end2 = high; //这个三个while循环会把两个容器里在的值都拿出来 while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) //这个while循环会把两个容器里在的值都拿出来，直到其中一个容器都没有了 b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++]; while (start1 &lt; end1) //当第一个的循环已经做完之后，肯定有一个容器都没有了，但是判断是不是第一个容器还有东西，如果有东西就全部取出来 b[k++] = a[start1++]; while (start2 &lt; end2) //当第一个的循环已经做完之后，肯定有一个容器都没有了，但是判断是不是第二个容器还有东西，如果有东西就全部取出来 b[k++] = a[start2++]; } /* * 下面三句是数组作为传参的精髓，数组作为传参进来的时候，是变成数组第一位的指针arr，指针传进来后可以对指针所指向的内容进行修改，但是怎么改都不会影响到外面arr的地址 * 所以一定每次处理的时候，都是要在arr地址上进行处理的，否则没有意义。【这是先验知识】 * 然后函数一开始就new了个b，这个b的地址是跟arr的地址不一样的 * 当b已经处理完后，要把b的东西给a，不能直接给，因为直接赋给a就是把b的地址给a，那么后续的处理时，arr的地址里内容还是没有变化呀 * 所以需要把a的地址暂时存放起来，此时一开始a的地址也是arr的地址，将其存放起来，再把b的地址给a，也就是把b里面的内容给了啊，因为，后续要拿a里的内容进行处理呀 * 此时做完第二句之后呢，a的地址和b的地址是一样的，再下一次for循环的时候，你不可以在同个地址上的内容上进行移动数值吧，那就出错了呀 * 类似【2,1】,处理后得到结果肯定变成【1,1】了 * 刚好又有个temp的地址可以使用，那就直接将temp的地址给b了，然后最后一次for循环处理后，b的地址还是在arr的地址之上 * */ T *temp = a; a = b; b = temp; } /* * 虽然下面的if语句注释了，也可以正常得到结果，但是按照逻辑来说的话，上面的最后一次循环之后，a拿到的是b的地址，所以拿到的是b里面的内容，所以要进行 * 一次判断，看a是不是的地址是不是还在arr的地址上，如果不是的话，但是此时b的地址肯定是在arr的地址上的（因为是temp一直在保存着arr的地址），所以只要把 * a的内容给b，b的地址又是arr的地址，所以处理完成后，arr的地址上指的内容肯定就被修改好了 * */ if (a != arr) { for (int i = 0; i &lt; len; i++) b[i] = a[i]; b = a; } delete[] b;} 上述的代码更加考验数组和指针之间的知识多一点，下面还有一个版本，通过每次排序后进行赋值的方式来减少指针上的操作，更加简单易懂些 1234567891011121314151617181920212223242526272829303132template&lt;typename T&gt; // 整數或浮點數皆可使用,若要使用物件(class)時必須設定\"小於\"(&lt;)的運算子功能void merge_sort2(T arr[], int len) { //不使用指针交换的方式 /* * 这道题超级考验数组传参时指针的知识 * */ T *b = new T[len]; for (int seg = 1; seg &lt; len; seg += seg) { //第一个循环，让最初始的一个容器开始进行融合，然后容器内容从1到2到4 for (int start = 0; start &lt; len; start += seg + seg) { //第二个循环，让每次相邻的两个容器进行排序 int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len); // 比较的容器：第一个容器是从low到mid，第二个容器是从mid到high，然后循环的时候会一直增加两个容器的内容，也就是seg //low ，mid，high都是每次比较容器的下标，所以要跟长度相比取最小， // 有可能最后一次容器比较的时候，只有一个容器了，且容器的大小不足所以mid最后取到len，也可能第二容器不够seg了，只能取到len了 int k = low; //将本次比较的两个容器的起始头拿出来，在这里一个个赋值 int start1 = low, end1 = mid; //将两个容器的起始头拿出来 int start2 = mid, end2 = high; //这个三个while循环会把两个容器里在的值都拿出来 while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) //这个while循环会把两个容器里在的值都拿出来，直到其中一个容器都没有了 b[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; while (start1 &lt; end1) //当第一个的循环已经做完之后，肯定有一个容器都没有了，但是判断是不是第一个容器还有东西，如果有东西就全部取出来 b[k++] = arr[start1++]; while (start2 &lt; end2) //当第一个的循环已经做完之后，肯定有一个容器都没有了，但是判断是不是第二个容器还有东西，如果有东西就全部取出来 b[k++] = arr[start2++]; } //在这里不能直接将b直接给a，否则就是将b的地址给arr了，后续就再也无法在arr的地址上进行运算【这里讨论的arr是指实参】 for(int i=0;i&lt;len;i++) { arr[i] = b[i]; } } delete[] b;} 5.分析如果有n个数，最多需要走n-1次遍历就可以排好平均时间复杂度：O(nlogn)最佳时间复杂度：O(n)最差时间复杂度：O(nlogn)空间复杂度：O(n) 6.参考https://zhuanlan.zhihu.com/p/75678113https://zhuanlan.zhihu.com/p/124356219","link":"/2020/08/06/Sort%EF%BC%9AMerge-Sort/"},{"title":"First Blog","text":"今天，我开始写人生中的第一篇博客 不知道自己会不会半途而废 不知道有多少人能看到这个主页 但不管如何，开始了，就坚持吧 现在的我是深大研二的一个学生 希望能记录我的点点滴滴 多年以后的你在做什么呢，旁边又有谁陪伴着你呢 家人的人都怎样了 你还坚守初心做一个好人吗 希望未来你能幸福下去 ps:图片拍摄于2020年4月9号傍晚，看到落日下, 一家人在空地玩耍，在天空飘满泡泡的时候。","link":"/2020/04/09/essay1/"},{"title":"想见你","text":"《想见你》也太好看了吧，第一次通宵看剧了 最近一直在循环《Last Dance》 早上突然有个白目的想法 我一直循环着这首歌会不会也穿越到另一个人身上呢 笑死了","link":"/2020/04/20/essay2/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"}],"categories":[{"name":"Learning notes","slug":"Learning-notes","link":"/categories/Learning-notes/"},{"name":"BackEnd","slug":"Learning-notes/BackEnd","link":"/categories/Learning-notes/BackEnd/"},{"name":"Algorithm","slug":"Learning-notes/Algorithm","link":"/categories/Learning-notes/Algorithm/"},{"name":"Spring Boot","slug":"Learning-notes/BackEnd/Spring-Boot","link":"/categories/Learning-notes/BackEnd/Spring-Boot/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"Sort","slug":"Learning-notes/Algorithm/Sort","link":"/categories/Learning-notes/Algorithm/Sort/"}]}